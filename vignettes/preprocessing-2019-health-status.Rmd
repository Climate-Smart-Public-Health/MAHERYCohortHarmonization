---
title: "Preprocessing 2019 Health Status"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Preprocessing 2019 Health Status}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r}
library(MAHERYCohortHarmonization)
```

<!-- WARNING - This vignette is generated by {fusen} from dev/flat_preprocess_2019_health.Rmd: do not edit by hand -->



```{r setup}
library(here)
library(targets)
tar_load(dharma2019, store = here::here("_targets"))

# Load already included functions if relevant
pkgload::load_all(export_all = FALSE)

library(janitor)
library(dplyr)
library(tidyr)
library(lubridate)
library(skimr)
library(forcats)
library(stringr)
library(ggplot2)
```


This notebooks deals with the 2019 file's health data.

Let's begin:

## Level 1 Health Data

The data is organized into 2 levels, where level 1 is the individual
baseline data, and level 2 is the follow up data.

### Reading in the data

The data is read in from the targets pipeline, and is contained in the `dharma2019` object.

To get the same number of rows we rerun the same NA filtering as
in the cohort 2019 notebook:
```{r}
cohort_df <- dharma2019$`Level 1 Named`

# create household head name
household_df <- dharma2019$`Level 0 Named` %>%
  select(fact_0_id, L0_q2_hh_name) %>%
  rename(hh_head_name = L0_q2_hh_name) %>%
  distinct() %>%
  mutate(hh_head_name = na_if(hh_head_name,".")) %>%
  filter(!is.na(hh_head_name))

# some na filtering
cohort_df %>%
  fill(fact_0_id, .direction = "down") %>%
  filter(!is.na(L1_q39_date)) %>%
  filter(L1_q39_date != ".") %>% 
  filter(!is.na(L1_q1_name)) %>%
  filter(L1_q1_name != ".") %>% 
  filter(!is.na(L1_q1_name)) %>%
  filter(L1_q1_name != ".") %>% 
  filter(!is.na(L1_q8_gender)) %>%
  filter(L1_q8_gender != ".") %>%
  filter(!is.na(L1_q2_dob_year)) %>%
  filter(L1_q2_dob_year != ".") %>%

  #join household head name
  left_join(household_df, by = "fact_0_id") -> cohort_2019_health
```


We can use the data dictionary to see what columns are available.
```{r}
dharma2019_dict <- dharma2019$`Data Dictionary`
dharma2019_dict %>%
  fill(level, .direction = "down") -> dharma2019_dict

level_1_dict <- dharma2019_dict %>%
  filter(level == 1)
level_1_dict

level_1_dict <- dharma2019_dict %>%
  filter(level == 1)
level_1_dict
```


Now, to get the matching health columns for 2019, we match the
2018 health columns to the most relevant 2019 columns.

### Health Care Access & Diagnoses

This section will align with the `prior_health_care` and `prior_diagnoses` sections
```{r}
cohort_2019_health %>%
  select(L1_q16_visit_hosp_clinic) %>%
  table()
```


```{r}
cohort_2019_health %>%
  mutate(prior_health_care_clean = case_when(
    L1_q16_visit_hosp_clinic == "Yes" ~ "Yes",
    L1_q16_visit_hosp_clinic == "No" ~ "No",
    L1_q16_visit_hosp_clinic == "IDK" ~ "Unknown",
    TRUE ~ NA_character_
  ) %>% as.factor()) -> cohort_2019_health_
```


We fortunately already have the diagnoses in wide format so we can work with that:
```{r}
diagnoses <- level_1_dict %>%
  fill(column_name, .direction = "down") %>%
  filter(str_detect(column_name, "q17_diagnostic")) %>%
  select(choice_name) %>%
  pull(choice_name) %>%
  make_clean_names() %>%
  str_replace_all("vih", "hiv") %>%
  str_c("diag_", ., "_clean")

```


Now, we can rename the columns in the health table with these
diagnoses:
```{r}
ind_diagnoses <- names(cohort_2019_health_) %>%
  str_detect("L1_q17_diagnostic") %>%
  which()

names(cohort_2019_health_)[ind_diagnoses] <- diagnoses
```


```{r}
cohort_2019_health_ %>%
  mutate(across(contains("diag_"), ~ case_when(
    . == "." ~ NA,
    . == NA ~ NA,
    TRUE ~ TRUE
  ) %>% as.factor())) -> cohort_2019_health_
  
cohort_2019_health_%>%
  select(contains("diag_")) %>%
  summary()
```


Much easier! Now, we deal with the "other" diagnoses:
```{r}
cohort_2019_health_ %>%
  tabyl(L1_q18_other_diagnostic)
```


This will require some manual cleaning as well as the same strategy for
cleaning the "other" diagnoses as we did in the 2018 notebook, using a
translation lookup table.

We'll leave this for now.

### Vaccinations

Categorising vaccinations will be similar to 2018:
```{r}
cohort_2019_health_ %>%
  select(L1_q26_vaccine_card) %>%
  table()
```


## Level 2 Health Data

In addition to this, there are level 2 health data that is collected
for each individual multiple times per year. These are called `followups`.
```{r}
cohort_2019_anthro <- dharma2019$`Level 2 Named`
level_2_dict <- dharma2019_dict %>%
  filter(level == 2)
```


The level 2 data is collected at the following time points:
```{r}
cohort_2019_anthro %>%
  select(L2_q38_date_followup) %>%
  mutate(date = L2_q38_date_followup %>%
    na_if("\\.") %>% 
    as.numeric() %>%
    convert_to_date()) %>%
  select(date) %>%
  ggplot(aes(x = date)) +
  geom_histogram(binwidth = 30) +
  labs(title = "Level 2 data collection dates in 2019", x = "Date", y = "Count")
```


As we can see, the data is supposed to correspond to a 2019 data collection
window, but extends to almost the end of 2020.

Naively, we can check to see if people get multiple surveys:
```{r}
cohort_2019_anthro %>%
  fill(fact_1_id, .direction = "down") %>%
  filter(!deleted) %>%
  group_by(fact_1_id) %>%
  summarise(n_surveys = n()) %>%
  arrange(-n_surveys)
```


It seems that an individual could have 20 entries in one
file:
```{r}
cohort_2019_anthro %>%
  fill(fact_0_id, fact_1_id, .direction = "down") %>%
  filter(!deleted) %>%
  filter(fact_1_id == 8864710) %>%
  mutate(date = L2_q38_date_followup %>%
    na_if("\\.") %>% 
    as.numeric() %>%
    convert_to_date()) %>%
  select(date) %>% table()
```


Ok, it is encouraging that the dates are all different. This would mean that,
for some people, they have multiple follow ups in the same year.

Let's see how many follows ups the average person has:
```{r}
cohort_2019_anthro %>%
  fill(fact_0_id, fact_1_id, .direction = "down") %>%
  filter(!deleted)
```


Ok, with that known, we can preprocess these anthro entries. We know
that each individual can have multiple entries, so we need to remove the deleted entries
and then order each individual by date to know which follow up is which:
```{r}
cohort_2019_anthro %>%
  fill(fact_0_id, fact_1_id, .direction = "down") %>%
  filter(!deleted) %>%
  filter(L2_q38_date_followup != ".") %>%
  mutate(date_clean = L2_q38_date_followup %>%
    na_if("\\.") %>% 
    as.numeric() %>%
    convert_to_date()) -> cohort_2019_anthro_
```


### Demographics

First, we look at the demographics within follow ups.

The status of the individual is first:
```{r}
cohort_2019_anthro_ %>%
  select(fact_1_id, L2_q41_alive) %>%
  tabyl(L2_q41_alive)
```


```{r}
cohort_2019_anthro_ %>%
  tabyl(L2_q47_participate)
```


```{r}
cohort_2019_anthro_ %>%
  tabyl(L2_q46_present)
```


This filters out the individuals who are not alive, not participating, or not present.
```{r}
cohort_2019_anthro_ %>%
  filter(L2_q47_participate == "Yes") %>%
  filter(L2_q41_alive == "Yes") %>%
  filter(L2_q46_present == "Yes") -> cohort_2019_anthro_
```


### Maternal Health

Now we look at recent pregnancies:
```{r}
cohort_2019_anthro_ %>%
  select(fact_1_id, L2_q196_live_birth) %>%
  tabyl(L2_q196_live_birth)
```


60 individuals is enough to keep around:
```{r}
cohort_2019_anthro_ %>%
  mutate(recent_birth_clean = case_when(
    L2_q196_live_birth == "Yes" ~ TRUE,
    L2_q196_live_birth == "No" ~ FALSE,
    L2_q196_live_birth == "." ~ NA,
    TRUE ~ NA
  ) %>% as.factor()) -> cohort_2019_anthro_
```


If they are currently pregnant:
```{r}
cohort_2019_anthro_ %>%
  select(fact_1_id, L2_q200_pregnant_now) %>%
  tabyl(L2_q200_pregnant_now)
```


That's a large number of individuals who are pregnant, so we can keep this
column as well:
```{r}
cohort_2019_anthro_ %>%
  mutate(pregnant_now_clean = case_when(
    L2_q200_pregnant_now == "Yes" ~ TRUE,
    L2_q200_pregnant_now == "No" ~ FALSE,
    L2_q200_pregnant_now == "." ~ NA,
    TRUE ~ NA
  ) %>% as.factor()) -> cohort_2019_anthro_
```


The other pregnancy columns do not seem to be relevant for analysis, but we
may include them later.

### Diagnoses

Recent diagnoses are collected here as well. We're going to use the
lookup table from the 2018 data to rename the columns:
```{r}
diagnoses <- level_2_dict %>%
  fill(column_name, .direction = "down") %>%
  filter(str_detect(column_name, "q62_diagnostic")) %>%
  mutate(raw = make_clean_names(choice_name)) %>%
  select(raw) %>%
  left_join(malagasy_diagnosis_lookup_table) %>%
  pull(diagnosis_english) %>%
  str_c("diag_", ., "_clean")

ind_diagnoses <- names(cohort_2019_anthro_) %>%
  str_detect("q62_diagnostic") %>%
  which()

names(cohort_2019_anthro_)[ind_diagnoses] <- diagnoses
```


### Symptoms

We can process the set of specific symptoms next:
```{r}
cohort_2019_anthro_ %>%

  #diarrhea
  mutate(symptom15dys_diarrhea_clean = case_when(
    L2_q94_diarrhea_now_15days == "Yes" ~ TRUE,
    L2_q94_diarrhea_now_15days == "No" ~ FALSE,
    L2_q94_diarrhea_now_15days == "." ~ NA,
    TRUE ~ NA
  ) %>% as.factor()) %>%

  #fever
  mutate(symptom15dys_fever_clean = case_when(
    L2_q117_fever_now_15days == "Yes" ~ TRUE,
    L2_q117_fever_now_15days == "No" ~ FALSE,
    L2_q117_fever_now_15days == "." ~ NA,
    TRUE ~ NA
  ) %>% as.factor()) %>%

  # emesis
  mutate(symptom15dys_vomit_clean = case_when(
    L2_q137_vomit_now_15days == "Yes" ~ TRUE,
    L2_q137_vomit_now_15days == "No" ~ FALSE,
    L2_q137_vomit_now_15days == "." ~ NA,
    TRUE ~ NA
  ) %>% as.factor()) %>%

  # headache
  mutate(symptom15dys_headache_clean = case_when(
    L2_q236_headache_15days == "Yes" ~ TRUE,
    L2_q236_headache_15days == "No" ~ FALSE,
    L2_q236_headache_15days == "." ~ NA,
    TRUE ~ NA
  ) %>% as.factor()) -> cohort_2019_anthro_
```


## Structure

We will add a function to show us what the time frame
of a specific person's follow up is:
```{r}
cohort_2019_anthro_ %>%
  mutate(uuid_clean = fact_1_id) %>%
  group_by(uuid_clean) %>%
  arrange(uuid_clean, date_clean) %>%
  mutate(followup_number_clean = row_number()) %>%
  ungroup() %>%
  mutate(across(contains("diag_"), ~ case_when(
    . == "." ~ NA,
    . == NA ~ NA,
    TRUE ~ TRUE
  ) %>% as.factor())) %>%
  rename(village_clean = L2_q791_enumerator) %>%
  select(contains('clean')) %>%
  select(-contains("L2")) %>%
  select(uuid_clean, followup_number_clean, date_clean, village_clean, everything()) %>%
  readr::write_csv(here("sandbox", "cohort_2019_health_followups.csv"))

```


# preprocess_rdp_health_subset

This function will preprocess a subset of the RDP health data for 2019.
  

  
  

# preprocess_2019_health

* This function should output month-individuals as rows, where each unit of
measure constitutes one person's month's data.

* For rolling up the clinic to cohort data, we can roll up the
symptoms to ICD10 codes, but preserve the original translations in table.

* see: https://docs.google.com/presentation/d/10ftfDtWDckiPdgOmpoFd9Y2X1cfeLvuT9zPdMZKbmNI/



```{r examples-preprocess_2019_health}
preprocess_2019_health()
```




